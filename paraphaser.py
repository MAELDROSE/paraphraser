# -*- coding: utf-8 -*-
"""paraphaser.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nqPoaWhY_d-ozlPjEIpaOuAbr66wwp4s
"""



import argparse
import random
import time
import sys
from typing import List, Tuple, Dict
import requests
from bs4 import BeautifulSoup
import os
from datetime import datetime
from difflib import SequenceMatcher
import re
import subprocess
import importlib

# Verificar e instalar dependencias
def install_package(package):
    try:
        importlib.import_module(package)
    except ImportError:
        print(f"Instalando {package}...")
        subprocess.check_call([sys.executable, "-m", "pip", "install", package])

# Solo dependencias esenciales
required_packages = ["requests", "beautifulsoup4"]

for package in required_packages:
    install_package(package)

import requests
from bs4 import BeautifulSoup

MOBILE_URL = "https://translate.google.com/m"

# ESTRATEGIAS CONCEPTUALES - Enfocadas en reformulaci√≥n de ideas
CONCEPTUAL_STRATEGIES = {
    "reformulacion_profunda": ["ja", "ko", "zh-CN", "ar", "he"],  # Cambio conceptual radical
    "reestructuracion": ["de", "nl", "sv", "da", "no"],  # Reorganizaci√≥n de ideas
    "recontextualizacion": ["ru", "pl", "tr", "el", "hi"],  # Nuevo contexto
    "sintesis_conceptual": ["fr", "it", "pt", "ca", "gl"]  # S√≠ntesis de conceptos
}

ALL_LANGS = [lang for group in CONCEPTUAL_STRATEGIES.values() for lang in group]

UA = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36"

class ConceptualParaphraser:
    """Sistema de par√°frasis conceptual - Reformula IDEAS no solo palabras"""

    def __init__(self):
        self.conceptual_patterns = {
            'academic_structures': {
                r'en conclusi√≥n': 'sintetizando las ideas principales',
                r'por otro lado': 'desde una perspectiva alternativa',
                r'en cuanto a': 'respecto al tema de',
                r'cabe destacar': 'resulta relevante mencionar',
                r'es importante se√±alar': 'conviene resaltar',
                r'de acuerdo con': 'en consonancia con',
                r'en relaci√≥n a': 'vinculado con el aspecto de',
                r'por lo tanto': 'derivado de lo anterior',
                r'como se puede observar': 'tal como es posible apreciar',
                r'en primer lugar': 'inicialmente',
                r'finalmente': 'para concluir este punto'
            },
            'conceptual_frameworks': {
                r'estudio': 'an√°lisis sistem√°tico',
                r'investigaci√≥n': 'exploraci√≥n acad√©mica',
                r'm√©todo': 'enfoque metodol√≥gico',
                r'resultado': 'hallazgo obtenido',
                r'an√°lisis': 'examen detallado',
                r'objetivo': 'prop√≥sito central',
                r'conclusi√≥n': 'derivaci√≥n final',
                r'marco te√≥rico': 'sustento conceptual',
                r'variables': 'elementos de estudio',
                r'hip√≥tesis': 'premisa de trabajo'
            }
        }

        # Patrones para preservar IDENTIDAD conceptual
        self.identity_patterns = {
            'dates': r'\b(19|20)\d{2}\b',
            'key_numbers': r'\b\d{3,}\b',
            'proper_nouns': r'\b[A-Z][a-z]+(?:\s+[A-Z][a-z]+)*\b',
            'acronyms': r'\b[A-Z]{2,5}\b'
        }

    def calculate_conceptual_similarity(self, original: str, paraphrased: str) -> float:
        """Calcula similitud a nivel conceptual, no solo textual"""
        # 1. Similitud b√°sica de contenido
        content_similarity = SequenceMatcher(None, original.lower(), paraphrased.lower()).ratio()

        # 2. Preservaci√≥n de ideas clave
        key_ideas_similarity = self._key_ideas_preservation(original, paraphrased)

        # 3. Variaci√≥n estructural (qu√© tan diferente est√° organizado)
        structural_variation = self._structural_variation(original, paraphrased)

        # 4. Innovaci√≥n conceptual (nuevas formas de expresar)
        conceptual_innovation = self._conceptual_innovation(original, paraphrased)

        # Ponderaci√≥n para PAR√ÅFRASIS CONCEPTUAL
        # Queremos alta preservaci√≥n de ideas pero alta variaci√≥n de expresi√≥n
        conceptual_score = (content_similarity * 0.2 +
                          key_ideas_similarity * 0.4 +
                          structural_variation * 0.2 +
                          conceptual_innovation * 0.2)

        return conceptual_score

    def _key_ideas_preservation(self, text1: str, text2: str) -> float:
        """Eval√∫a cu√°ntas ideas clave se preservaron"""
        # Extraer ideas principales (oraciones con sustantivos y verbos clave)
        ideas1 = self._extract_key_ideas(text1)
        ideas2 = self._extract_key_ideas(text2)

        if not ideas1 or not ideas2:
            return 0.0

        # Comparar ideas sem√°nticamente, no literalmente
        matching_ideas = 0
        for idea1 in ideas1:
            for idea2 in ideas2:
                if self._semantic_similarity(idea1, idea2) > 0.6:
                    matching_ideas += 1
                    break

        return matching_ideas / len(ideas1)

    def _extract_key_ideas(self, text: str) -> List[str]:
        """Extrae las ideas principales del texto"""
        # Dividir en oraciones y filtrar las m√°s significativas
        sentences = [s.strip() for s in re.split(r'[.!?]+', text) if s.strip()]

        key_ideas = []
        for sentence in sentences:
            # Considerar oraciones con contenido sustancial
            words = sentence.split()
            if len(words) >= 5:  # Oraciones con al menos 5 palabras
                # Ponderar oraciones con sustantivos y verbos
                if len(re.findall(r'\b(el|la|los|las)\b', sentence.lower())) > 0:
                    key_ideas.append(sentence)

        return key_ideas if key_ideas else sentences[:3]  # Fallback: primeras 3 oraciones

    def _semantic_similarity(self, text1: str, text2: str) -> float:
        """Similitud sem√°ntica b√°sica basada en palabras clave"""
        words1 = set(re.findall(r'\b[a-z√°√©√≠√≥√∫√±]{4,}\b', text1.lower()))
        words2 = set(re.findall(r'\b[a-z√°√©√≠√≥√∫√±]{4,}\b', text2.lower()))

        if not words1 or not words2:
            return 0.0

        intersection = len(words1.intersection(words2))
        union = len(words1.union(words2))

        return intersection / union if union > 0 else 0

    def _structural_variation(self, text1: str, text2: str) -> float:
        """Mide qu√© tan diferente es la estructura (valoramos alta variaci√≥n)"""
        # Longitud de oraciones
        sent1_lengths = [len(s.split()) for s in re.split(r'[.!?]+', text1) if s.strip()]
        sent2_lengths = [len(s.split()) for s in re.split(r'[.!?]+', text2) if s.strip()]

        if not sent1_lengths or not sent2_lengths:
            return 0.5  # Valor neutral

        # Diferencia en longitud promedio (valoramos diferencia)
        avg_len1 = sum(sent1_lengths) / len(sent1_lengths)
        avg_len2 = sum(sent2_lengths) / len(sent2_lengths)
        length_variation = abs(avg_len1 - avg_len2) / max(avg_len1, avg_len2)

        # Diferencia en n√∫mero de oraciones
        count_variation = abs(len(sent1_lengths) - len(sent2_lengths)) / max(len(sent1_lengths), len(sent2_lengths))

        return (length_variation + count_variation) / 2

    def _conceptual_innovation(self, original: str, paraphrased: str) -> float:
        """Mide cu√°ntas nuevas expresiones conceptuales se introdujeron"""
        original_phrases = self._extract_conceptual_phrases(original)
        paraphrased_phrases = self._extract_conceptual_phrases(paraphrased)

        if not original_phrases or not paraphrased_phrases:
            return 0.5

        # Contar frases que son conceptualmente diferentes
        innovative_phrases = 0
        for p_phrase in paraphrased_phrases:
            is_innovative = True
            for o_phrase in original_phrases:
                if self._semantic_similarity(p_phrase, o_phrase) > 0.7:
                    is_innovative = False
                    break
            if is_innovative:
                innovative_phrases += 1

        return innovative_phrases / len(paraphrased_phrases)

    def _extract_conceptual_phrases(self, text: str) -> List[str]:
        """Extrae frases que contienen conceptos importantes"""
        # Buscar patrones de frases acad√©micas/conceptuales
        phrases = []

        # Frases de 4-7 palabras que probablemente contengan ideas
        words = text.split()
        for i in range(len(words) - 3):
            for j in range(4, min(8, len(words) - i + 1)):
                phrase = ' '.join(words[i:i + j])
                # Filtrar frases que parecen contener ideas sustanciales
                if (len(phrase) > 20 and
                    any(keyword in phrase.lower() for keyword in ['que', 'como', 'para', 'por', 'sobre'])):
                    phrases.append(phrase)

        return phrases[:10]  # Limitar a 10 frases principales

    def apply_conceptual_reframing(self, text: str) -> str:
        """Reformula el texto a nivel conceptual manteniendo las ideas propias"""
        result = text

        # Aplicar reformulaciones conceptuales
        for pattern, replacement in self.conceptual_patterns['academic_structures'].items():
            result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)

        for pattern, replacement in self.conceptual_patterns['conceptual_frameworks'].items():
            result = re.sub(pattern, replacement, result, flags=re.IGNORECASE)

        return result

    def preserve_conceptual_identity(self, text: str) -> Dict:
        """Preserva elementos que definen la identidad conceptual del texto"""
        identity_elements = {}

        for element_type, pattern in self.identity_patterns.items():
            matches = re.findall(pattern, text)
            if matches:
                identity_elements[element_type] = matches

        return identity_elements

def translate_conceptual(text: str, src: str, dst: str, timeout: float = 35.0) -> str:
    """Traducci√≥n enfocada en preservar conceptos, no solo palabras"""
    clean_text = text.strip()

    if len(clean_text) > 800:
        return _translate_conceptual_chunked(clean_text, src, dst, timeout)

    params = {"sl": src, "tl": dst, "q": clean_text}
    headers = {"User-Agent": UA}

    try:
        response = requests.get(MOBILE_URL, params=params, headers=headers, timeout=timeout)
        response.raise_for_status()
        soup = BeautifulSoup(response.text, "html.parser")

        # Estrategias de b√∫squeda mejoradas
        selectors = ["div.result-container", "div.t0", "div.par", ".result-container", "div[class*='translation']"]
        result_box = None

        for selector in selectors:
            result_box = soup.select_one(selector)
            if result_box and result_box.text.strip():
                break

        if not result_box:
            # B√∫squeda de respaldo: cualquier div con texto sustancial
            all_divs = soup.find_all('div')
            for div in all_divs:
                text_content = div.get_text(strip=True)
                if (text_content and
                    len(text_content) > len(clean_text) * 0.3 and
                    text_content != clean_text):
                    result_box = div
                    break

        if result_box:
            result = result_box.get_text(strip=True)
            if result and len(result) > len(clean_text) * 0.4:
                return result

        return clean_text  # Fallback conservador

    except requests.exceptions.RequestException as e:
        print(f"  üîÑ Reintentando {src}‚Üí{dst}...")
        time.sleep(5)
        raise

def _translate_conceptual_chunked(text: str, src: str, dst: str, timeout: float) -> str:
    """Divide y traduce preservando flujo conceptual"""
    # Dividir en unidades conceptuales (p√°rrafos o grupos de oraciones)
    paragraphs = [p.strip() for p in text.split('\n') if p.strip()]
    if not paragraphs:
        paragraphs = re.split(r'(?<=[.!?])\s+', text)

    translated_paragraphs = []

    for i, paragraph in enumerate(paragraphs):
        try:
            if len(paragraph) > 600:
                # Subdividir p√°rrafos muy largos
                sentences = re.split(r'(?<=[.!?])\s+', paragraph)
                sub_chunks = []
                current_chunk = ""

                for sentence in sentences:
                    if len(current_chunk) + len(sentence) < 500:
                        current_chunk += sentence + " "
                    else:
                        if current_chunk:
                            sub_chunks.append(current_chunk.strip())
                        current_chunk = sentence + " "

                if current_chunk:
                    sub_chunks.append(current_chunk.strip())

                translated_sub_chunks = []
                for chunk in sub_chunks:
                    translated = translate_conceptual(chunk, src, dst, timeout)
                    translated_sub_chunks.append(translated)
                    time.sleep(2)

                translated_paragraphs.append(" ".join(translated_sub_chunks))
            else:
                translated = translate_conceptual(paragraph, src, dst, timeout)
                translated_paragraphs.append(translated)
                time.sleep(2)

        except Exception as e:
            print(f"    ‚ùå Error en p√°rrafo {i+1}, usando original")
            translated_paragraphs.append(paragraph)

    return "\n".join(translated_paragraphs)

def generate_conceptual_strategies(original_length: int) -> List[List[str]]:
    """Genera estrategias enfocadas en reformulaci√≥n conceptual"""
    strategies = []

    # Estrategias conceptuales predefinidas
    conceptual_flows = [
        # Reformulaci√≥n profunda (cambio radical de expresi√≥n)
        ["ja", "ko", "zh-CN", "ar", "he"],
        ["ru", "pl", "tr", "el", "hi"],
        # Recontextualizaci√≥n (nuevo marco conceptual)
        ["de", "nl", "sv", "da", "no"],
        ["fr", "it", "pt", "ca", "gl"],
        # S√≠ntesis conceptual (compactaci√≥n de ideas)
        ["ja", "ko", "zh-CN", "de", "nl"],
        ["ar", "he", "ru", "pl", "fr"],
        # Expansi√≥n conceptual (desarrollo de ideas)
        ["it", "pt", "ca", "el", "hi"],
        ["tr", "sv", "da", "no", "gl"]
    ]

    # Estrategias mixtas para diferentes tipos de texto
    mixed_strategies = [
        ["ja", "de", "fr", "it"],  # Asi√°tico + Europeo balanceado
        ["ko", "nl", "pt", "el"],  # Coreano con lenguas romances/germ√°nicas
        ["zh-CN", "sv", "ca", "hi"],  # Chino con mezcla diversa
        ["ar", "da", "gl", "tr"],  # √Årabe con lenguas menores
        ["he", "no", "ru", "pl"]   # Hebreo con eslavos
    ]

    strategies.extend(conceptual_flows)
    strategies.extend(mixed_strategies)

    # Ajustar seg√∫n longitud
    if original_length > 1500:
        # Para textos largos, estrategias m√°s conservadoras
        strategies = [s[:3] for s in strategies if len(s) > 3]
    elif original_length < 500:
        # Para textos cortos, estrategias m√°s intensas
        strategies = [s + random.sample(ALL_LANGS, 2) for s in strategies]

    random.shuffle(strategies)
    return strategies[:10]  # Hasta 10 estrategias

def conceptual_paraphrase(
    text: str,
    conceptual_target: float = 0.65,  # 65% preservaci√≥n conceptual, 35% innovaci√≥n
    max_attempts: int = 8,
    max_time: int = 360,  # 6 minutos m√°ximo
    verbose: bool = True
) -> Tuple[str, float, List[Dict]]:
    """
    Par√°frasis CONCEPTUAL - Reformula IDEAS propias, no solo palabras
    """
    conceptual_engine = ConceptualParaphraser()
    start_time = time.time()
    attempts_log = []

    best_result = text
    best_conceptual_score = 1.0
    identity_elements = conceptual_engine.preserve_conceptual_identity(text)

    if verbose:
        print("üß† ACTIVANDO PAR√ÅFRASIS CONCEPTUAL")
        print(f"üìä Texto original: {len(text)} caracteres")
        print(f"üéØ Objetivo: {conceptual_target*100:.0f}% preservaci√≥n conceptual")
        print("üí° Reformulando IDEAS propias...")

    strategies = generate_conceptual_strategies(len(text))

    for attempt, strategy in enumerate(strategies[:max_attempts], 1):
        if time.time() - start_time > max_time:
            break

        try:
            if verbose:
                print(f"\n--- Intento Conceptual {attempt} ---")
                print(f"üîÑ Ruta conceptual: es ‚Üí {' ‚Üí '.join(strategy)} ‚Üí es")

            current_text = text

            # APLICAR CADA TRADUCCI√ìN CON ENFOQUE CONCEPTUAL
            conceptual_route = ["es"] + strategy + ["es"]

            for i, (src, dst) in enumerate(zip(conceptual_route[:-1], conceptual_route[1:])):
                if verbose:
                    print(f"   üß© {src} ‚Üí {dst} (Paso {i+1}/{len(conceptual_route)-1})...")

                current_text = translate_conceptual(current_text, src, dst)

                # Delay conceptual (tiempo para "digesti√≥n" de ideas)
                conceptual_delay = 2.0 + (i * 0.8) + random.uniform(0.5, 2.0)
                time.sleep(conceptual_delay)

            # APLICAR REFORMULACI√ìN CONCEPTUAL FINAL
            current_text = conceptual_engine.apply_conceptual_reframing(current_text)

            # CALCULAR PUNTUACI√ìN CONCEPTUAL
            conceptual_score = conceptual_engine.calculate_conceptual_similarity(text, current_text)

            # REGISTRAR INTENTO CONCEPTUAL
            attempt_data = {
                "attempt": attempt,
                "strategy": strategy,
                "result": current_text,
                "conceptual_score": conceptual_score,
                "time_elapsed": time.time() - start_time,
                "type": "conceptual"
            }
            attempts_log.append(attempt_data)

            if verbose:
                innovation = (1 - conceptual_score) * 100
                if innovation > 40:
                    status = "üí° ALTA INNOVACI√ìN"
                elif innovation > 25:
                    status = "üîÑ INNOVACI√ìN MODERADA"
                elif innovation > 15:
                    status = "‚öñÔ∏è  BALANCEADO"
                else:
                    status = "üéØ CONSERVADOR"

                print(f"   {status} | Innovaci√≥n conceptual: {innovation:.1f}%")
                print(f"   üìù Muestra: {current_text[:100]}...")

            # BUSCAR MEJOR BALANCE CONCEPTUAL
            current_distance = abs(conceptual_score - conceptual_target)
            best_distance = abs(best_conceptual_score - conceptual_target)

            if current_distance < best_distance:
                best_result = current_text
                best_conceptual_score = conceptual_score

                if verbose and abs(conceptual_score - conceptual_target) < 0.08:
                    print(f"   üéØ BALANCE CONCEPTUAL √ìPTIMO ENCONTRADO!")

            # SI ENCONTRAMOS BUENA REFORMULACI√ìN, CONTINUAR EXPLORANDO
            if abs(conceptual_score - conceptual_target) < 0.1:
                if verbose:
                    print(f"   üí´ Excelente reformulaci√≥n conceptual, probando variantes...")

        except Exception as e:
            if verbose:
                error_msg = str(e)
                if "timeout" in error_msg.lower():
                    print(f"   ‚è∞ Pausa conceptual necesaria...")
                else:
                    print(f"   ‚ùå Error conceptual: {error_msg[:40]}...")
            continue

        # PAUSA ENTRE ESTRATEGIAS CONCEPTUALES
        if attempt < len(strategies):
            conceptual_pause = random.uniform(3, 6)
            if verbose:
                print(f"   ‚è∏Ô∏è  Procesamiento conceptual ({conceptual_pause:.1f}s)...")
            time.sleep(conceptual_pause)

    if verbose:
        innovation_final = (1 - best_conceptual_score) * 100
        print(f"\n--- TRANSFORMACI√ìN CONCEPTUAL COMPLETADA ---")
        print(f"üèÜ Innovaci√≥n conceptual alcanzada: {innovation_final:.1f}%")
        print(f"‚è∞ Tiempo total: {time.time()-start_time:.1f}s")
        print(f"üß† Intentos conceptuales: {len(attempts_log)}")

    return best_result, best_conceptual_score, attempts_log

def enhance_conceptual_flow(text: str) -> str:
    """Mejora el flujo conceptual del texto final"""
    # Unificar espacios
    text = re.sub(r'\s+', ' ', text)

    # Mejorar puntuaci√≥n conceptual
    text = re.sub(r'\s+([.,;!?])', r'\1', text)
    text = re.sub(r'([.,;!?])([A-Za-z])', r'\1 \2', text)

    # Capitalizaci√≥n conceptual (despu√©s de puntos)
    sentences = [s.strip() for s in re.split(r'(?<=[.!?])\s+', text) if s.strip()]
    sentences = [s[0].upper() + s[1:] if s else "" for s in sentences]

    # Reconstruir con flujo mejorado
    conceptual_text = '. '.join(sentences)

    # Asegurar cierre conceptual
    if not conceptual_text.endswith(('.', '!', '?')):
        conceptual_text += '.'

    return conceptual_text

def save_conceptual_report(
    original: str,
    paraphrased: str,
    conceptual_score: float,
    attempts: List[Dict],
    filename: str = None
):
    """Guarda reporte de par√°frasis conceptual"""
    if filename is None:
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"parafrasis_conceptual_{timestamp}.txt"

    # Mejorar flujo conceptual final
    final_text = enhance_conceptual_flow(paraphrased)
    innovation = (1 - conceptual_score) * 100

    with open(filename, 'w', encoding='utf-8') as f:
        f.write("PAR√ÅFRASIS CONCEPTUAL - REFORMULACI√ìN DE IDEAS PROPIAS\n")
        f.write("=" * 60 + "\n\n")

        f.write(f"Fecha: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"Archivo: {filename}\n")
        f.write(f"Innovaci√≥n conceptual: {innovation:.1f}%\n")
        f.write(f"Intentos realizados: {len(attempts)}\n\n")

        f.write("TEXTO ORIGINAL (Ideas base):\n")
        f.write("-" * 35 + "\n")
        f.write(original + "\n\n")

        f.write("TEXTO REFORMULADO (Ideas propias expresadas diferente):\n")
        f.write("-" * 35 + "\n")
        f.write(final_text + "\n\n")

        f.write("AN√ÅLISIS CONCEPTUAL:\n")
        f.write("-" * 35 + "\n")
        f.write(f"‚Ä¢ Preservaci√≥n conceptual: {conceptual_score*100:.1f}%\n")
        f.write(f"‚Ä¢ Innovaci√≥n expresiva: {innovation:.1f}%\n")
        f.write(f"‚Ä¢ Longitud original: {len(original)} caracteres\n")
        f.write(f"‚Ä¢ Longitud final: {len(final_text)} caracteres\n")

        if innovation > 35:
            f.write("‚Ä¢ Evaluaci√≥n: ALTA INNOVACI√ìN CONCEPTUAL\n")
        elif innovation > 20:
            f.write("‚Ä¢ Evaluaci√≥n: INNOVACI√ìN MODERADA\n")
        else:
            f.write("‚Ä¢ Evaluaci√≥n: REFORMULACI√ìN CONSERVADORA\n")

        f.write("\nMEJORES FLUJOS CONCEPTUALES:\n")
        f.write("-" * 35 + "\n")

        # Ordenar por proximidad al objetivo (65% preservaci√≥n)
        best_attempts = sorted(attempts, key=lambda x: abs(x['conceptual_score'] - 0.65))[:3]

        for i, attempt in enumerate(best_attempts, 1):
            innov = (1 - attempt['conceptual_score']) * 100
            f.write(f"\n{i}. Innovaci√≥n: {innov:.1f}%\n")
            f.write(f"   Flujo: es ‚Üí {' ‚Üí '.join(attempt['strategy'])} ‚Üí es\n")
            f.write(f"   Tipo: {attempt.get('type', 'conceptual')}\n")

    return filename, final_text

def main():
    print("üß† SISTEMA DE PAR√ÅFRASIS CONCEPTUAL")
    print("=" * 55)
    print("üí° Enfocado en REFORMULAR IDEAS PROPIAS")
    print("üåç Manteniendo esencia conceptual con expresi√≥n renovada")
    print("‚ö° Tecnolog√≠a: Transformaci√≥n conceptual multiling√ºe")

    # Entrada de texto
    texto = input("\nüìù Introduce el texto con TUS IDEAS a reformular:\n> ")

    if not texto.strip():
        print("No se proporcionaron ideas para reformular.")
        return

    # CONFIGURACI√ìN CONCEPTUAL INTELIGENTE
    text_length = len(texto)

    if text_length > 2000:
        conceptual_target = 0.70  # M√°s preservaci√≥n para textos complejos
        max_attempts = 6
        max_time = 480  # 8 minutos
    elif text_length > 1000:
        conceptual_target = 0.65  # Balance ideal
        max_attempts = 7
        max_time = 360  # 6 minutos
    else:
        conceptual_target = 0.60  # M√°s innovaci√≥n para textos cortos
        max_attempts = 8
        max_time = 300  # 5 minutos

    print(f"\n‚öôÔ∏è  CONFIGURACI√ìN CONCEPTUAL:")
    print(f"   ‚Ä¢ Objetivo: {conceptual_target*100:.0f}% preservaci√≥n conceptual")
    print(f"   ‚Ä¢ Innovaci√≥n objetivo: {(1-conceptual_target)*100:.0f}%")
    print(f"   ‚Ä¢ Intentos m√°ximos: {max_attempts}")
    print(f"   ‚Ä¢ Tiempo m√°ximo: {max_time}s")
    print(f"   ‚Ä¢ Ideas a reformular: {text_length} caracteres")

    confirm = input("\n¬øIniciar reformulaci√≥n conceptual? (s/n): ").lower().strip()
    if confirm != 's':
        print("Reformulaci√≥n conceptual cancelada.")
        return

    try:
        # EJECUTAR PAR√ÅFRASIS CONCEPTUAL
        start_time = time.time()
        resultado, score_conceptual, historial = conceptual_paraphrase(
            texto,
            conceptual_target=conceptual_target,
            max_attempts=max_attempts,
            max_time=max_time,
            verbose=True
        )

        # GUARDAR RESULTADOS CONCEPTUALES
        archivo, texto_final = save_conceptual_report(
            texto, resultado, score_conceptual, historial
        )

        # MOSTRAR RESULTADOS CONCEPTUALES
        print("\n" + "=" * 65)
        print("‚úÖ REFORMULACI√ìN CONCEPTUAL COMPLETADA")
        print("=" * 65)

        innovacion = (1 - score_conceptual) * 100
        print(f"\nüìä RESULTADOS CONCEPTUALES:")
        print(f"   ‚Ä¢ Innovaci√≥n expresiva: {innovacion:.1f}%")
        print(f"   ‚Ä¢ Preservaci√≥n de ideas: {score_conceptual*100:.1f}%")
        print(f"   ‚Ä¢ Procesos conceptuales: {len(historial)}")
        print(f"   ‚Ä¢ Tiempo conceptual: {time.time()-start_time:.1f}s")

        # EVALUACI√ìN CONCEPTUAL
        if innovacion > 35:
            calidad = "üí° ALTA INNOVACI√ìN CONCEPTUAL"
        elif innovacion > 25:
            calidad = "üîÑ INNOVACI√ìN SIGNIFICATIVA"
        elif innovacion > 15:
            calidad = "‚öñÔ∏è  BALANCE CONCEPTUAL √ìPTIMO"
        else:
            calidad = "üéØ REFORMULACI√ìN CONSERVADORA"

        print(f"   ‚Ä¢ Calidad: {calidad}")

        print(f"\nüìù COMPARACI√ìN CONCEPTUAL:")
        print(f"   IDEAS ORIGINALES: {texto[:80]}...")
        print(f"   IDEAS REFORMULADAS: {texto_final[:80]}...")

        print(f"\nüíæ ARCHIVO CONCEPTUAL: {archivo}")
        print(f"üìÅ Ruta: {os.path.abspath(archivo)}")

        # RECOMENDACIONES CONCEPTUALES
        print(f"\nüí° RECOMENDACIONES CONCEPTUALES:")
        if innovacion < 15:
            print("   - Considera ejecutar con objetivo de mayor innovaci√≥n")
            print("   - Tus ideas pueden expresarse de formas m√°s diversas")
        elif innovacion > 45:
            print("   - Verifica que se mantiene la esencia de tus ideas")
            print("   - Excelente diversificaci√≥n expresiva")
        else:
            print("   - Balance perfecto entre innovaci√≥n y preservaci√≥n")
            print("   - Tus ideas ahora tienen expresi√≥n √∫nica")

    except Exception as e:
        print(f"\n‚ùå Error en reformulaci√≥n conceptual: {e}")
        print("üí° Soluciones conceptuales:")
        print("   - Verifica tu conexi√≥n a internet")
        print("   - Las ideas muy complejas pueden necesitar divisi√≥n")
        print("   - Reintenta despu√©s de pausa conceptual")

if __name__ == "__main__":
    main()